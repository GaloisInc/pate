{-# LANGUAGE RankNTypes #-}
module Pate.Memory.Trace.ValidityPolicy (
    ValidityPolicy(..)
  , noValidityChecks
  ) where


import qualified Data.Macaw.Symbolic as DMS
import qualified Lang.Crucible.Backend as LCB
import qualified Lang.Crucible.Simulator as LCS

-- | This data type defines the validity policy to use in the trace-based memory model
--
-- The memory model has a number of decisions to make about what operations are
-- valid and how to enforce the validity of expressions/operations.  For
-- example, adding two pointers (with non-zero block IDs) is not valid and
-- doesn't have any particular meaning.  This data type enables users of the
-- trace memory based interpretation of macaw IR to express their policies for
-- this type of validity check.
--
-- This interface is designed to support two high-level methods for encoding
-- validity checks.
--
--  1. It can produce a /new/ extension that encodes validity checks "inline"
--     (i.e., as muxes embedded in the input terms). For example, this can
--     enforce that one of the arguments to 'DMS.PtrAdd' must have region 0 by
--     wrapping both region IDs of the arguments to 'DMS.PtrAdd' in muxes to
--     that effect.
--
--  2. Since it is in IO and can access the symbolic backend, it can assert
--     validity checks as side conditions that can be checked on the side.  It
--     could also capture an IORef or MVar to store side conditions in outside
--     of the normal assertion/assumption stack.  That is likely to be
--     advantageous, as we might not want to check the other validity assertions
--     generated by the symbolic execution.
--
-- It is expected that the second option will be more efficient, as we generally
-- want to avoid exploding the complexity of individual terms (particularly
-- those that are carried between slices).
data ValidityPolicy arch =
  ValidityPolicy { validateExpression :: forall sym tp . (LCB.IsSymInterface sym)
                                      => sym
                                      -> DMS.MacawExprExtension arch (LCS.RegValue' sym) tp
                                      -> IO (DMS.MacawExprExtension arch (LCS.RegValue' sym) tp)
                 , validateStatement :: forall sym tp . (LCB.IsSymInterface sym)
                                     => sym
                                     -> DMS.MacawStmtExtension arch (LCS.RegEntry sym) tp
                                     -> IO (DMS.MacawStmtExtension arch (LCS.RegEntry sym) tp)
                 }

-- | A set of validity checks that do no additional checking
noValidityChecks :: ValidityPolicy arch
noValidityChecks = ValidityPolicy { validateExpression = \_ e -> return e
                                  , validateStatement = \_ s -> return s
                                  }
