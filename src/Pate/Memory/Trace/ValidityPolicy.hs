{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE TypeOperators #-}
module Pate.Memory.Trace.ValidityPolicy (
  ValidityPolicy(..)
  ) where

import           GHC.TypeLits ( type (<=) )

import qualified Data.Macaw.CFG as DMC
import qualified Data.Macaw.Symbolic as DMS
import qualified Lang.Crucible.Backend as LCB
import qualified Lang.Crucible.Simulator as LCS

-- | This data type defines the validity policy to use in the trace-based memory model
--
-- The memory model has a number of decisions to make about what operations are
-- valid and how to enforce the validity of expressions/operations.  For
-- example, adding two pointers (with non-zero block IDs) is not valid and
-- doesn't have any particular meaning.  This data type enables users of the
-- trace memory based interpretation of macaw IR to express their policies for
-- this type of validity check.
--
-- This interface is designed to support two high-level methods for encoding
-- validity checks.
--
--  1. It can produce a /new/ extension that encodes validity checks "inline"
--     (i.e., as muxes embedded in the input terms). For example, this can
--     enforce that one of the arguments to 'DMS.PtrAdd' must have region 0 by
--     wrapping both region IDs of the arguments to 'DMS.PtrAdd' in muxes to
--     that effect.
--
--  2. Since it is in IO and can access the symbolic backend, it can assert
--     validity checks as side conditions that can be checked on the side.  It
--     could also capture an IORef or MVar to store side conditions in outside
--     of the normal assertion/assumption stack.  That is likely to be
--     advantageous, as we might not want to check the other validity assertions
--     generated by the symbolic execution.
--
-- It is expected that the second option will be more efficient, as we generally
-- want to avoid exploding the complexity of individual terms (particularly
-- those that are carried between slices).
--
-- There is a secondary component to the second strategy. In that case, the
-- extension must maintain a parallel, conservative, state of the world with the
-- necessary validity checks embedded in formulas that can be used when required
-- (i.e., when the checks on the side fail).
--
-- Note that these policies are intended to be invoked only for the pointer
-- operations; other uses may generate errors.
data ValidityPolicy sym arch =
  ValidityPolicy { validateExpression :: forall tp
                                       . sym
                                      -> DMS.MacawExprExtension arch (LCS.RegValue' sym) tp
                                      -> IO (LCS.RegValue sym tp)
                 , validateStatement :: forall tp
                                      . (1 <= DMC.ArchAddrWidth arch)
                                     => sym
                                     -> DMS.MacawStmtExtension arch (LCS.RegEntry sym) tp
                                     -> IO (LCS.RegValue sym tp)
                 }

